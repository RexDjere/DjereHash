// This file contains peer review information used to continuosly improve DjereHash.
************************************************************************************
Rev. 0.12

consistant coding style (brackets with spaces )
FIXED.
 
wrong indentation (at the end)
FIXED.
    
"while (Pcontinue == true)" -> "while (Pcontinue)"
FIXED.
    
"return 0;" at the end of "int main()" is no needed.
SKIPPED.
    
charSet is never changed, could be const
FIXED.
    
write a top comment explaining what your code does in general.
FIXED.
***************************************************************
Rev. 0.13

Comments like this are redundant: binSum = 0; // reset binSum to zero
FIXED.

your algorithm outputs the same hash regardless of the order of the last 4 input characters.
FIXED.

strange ordering of charSet array.
FIXED.

As this is C++ I would put the counters in the loops, i.e.: for(int i=0;i<256;i++)
FIXED.

Remove redundant binSum function.
FIXED.

simplify hash function.
FIXED.

better explain hash function with comment.
FIXED.

****************************************************************************************************
Rev. 0.14

All single character inputs result in same output hash.
FIXED.

****************************************************************************************************
Rev. 0.15

!@ collides with @! and 16.
FIXED.
****************************************************************************************************
Rev. 0.16
Simplified hashing function.
****************************************************************************************************
Rev 0.17

separate functionality into a separate procedure

You will need to be more rigorous than that, feeding whole dictionaries through your hash function.

Also, your hashing function appears to be of the form
h += input[i]*prime + input[i]%prime + constant[i]
This is an expensive hash function, with a multiply and a modulus operation per character of input.
Plus, you arent mixing in the earlier state very well.
A better hash function might be h+= (input[i]+h)*prime + (input[i]+h)% prime


There is plenty of literature about how to design a hash function. 
The thing about them is that they are as hard to design as good random functions, 
and as hard to test. You're better off using an existing, well tested hash function, 
or if you're determined to make your own, do the required research.

One rule for hash functions is that a change of any 1 bit of the input should result 
in every bit of the output changing with 50% probability.

There are other rules for good hash functions. 
see here http://burtleburtle.net/bob/hash/evahash.html





As hashBin[i] starts out at zero for each hash the line: hashBins[i] = hashBins[i] +.... 
can really just be hashBins[i] = .... which means the array is not needed at all.

I also wonder why are you adding every character from the input to binSum every i loop? 
Seems a constant that isn't doing much. 
This also seems true of the (i+1)%11, (i+2)%104729 and (i * 256) parts of the hash itself.


